package io.camunda.demo.pick_animal;

import io.camunda.zeebe.client.ZeebeClient;
import io.camunda.zeebe.client.api.command.DeployResourceCommandStep1;
import io.camunda.zeebe.client.api.response.DeploymentEvent;
import io.camunda.zeebe.client.api.response.ProcessInstanceEvent;
import io.camunda.zeebe.client.api.response.PublishMessageResponse;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.TimeoutException;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;

import io.camunda.zeebe.process.test.api.ZeebeTestEngine;
import io.camunda.zeebe.process.test.assertions.BpmnAssert;
import io.camunda.zeebe.process.test.extension.ZeebeProcessTest;

@SpringBootTest(classes = PickAnimalApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) // Use
																													// random
																													// port
																													// for
																													// web
																													// environment
// @SpringBootTest(classes = PickAnimalApplication.class) // Ensures the main
// class is found
@ZeebeProcessTest
class PickAnimalApplicationTest {

	private static final String PICK_ANIMAL_PROCESS_RESOURCE_NAME = "pick-an-animal.bpmn";
	private static final String PICK_ANIMAL_REQUEST_MSG = "reviewReceived";

	// injected by ZeebeProcessTest annotation
	private ZeebeTestEngine engine;
	// injected by ZeebeProcessTest annotation
	private ZeebeClient client;

	@BeforeEach
	void deployProcesses() {
		// The embedded engine is completely reset before each test run.
		// Therefore, we need to deploy the process each time

		final DeploymentEvent deploymentEvent = deployResources(PICK_ANIMAL_PROCESS_RESOURCE_NAME);

		BpmnAssert.assertThat(deploymentEvent)
				.containsProcessesByResourceName(
						PICK_ANIMAL_PROCESS_RESOURCE_NAME);
	}

	@Test
	void testDummy() {

		System.out.println("Testing");

	}

	private DeploymentEvent deployResources(final String... resources) {
		final DeployResourceCommandStep1 commandStep1 = client.newDeployResourceCommand();

		DeployResourceCommandStep1.DeployResourceCommandStep2 commandStep2 = null;
		for (final String process : resources) {
			if (commandStep2 == null) {
				commandStep2 = commandStep1.addResourceFromClasspath(process);
			} else {
				commandStep2 = commandStep2.addResourceFromClasspath(process);
			}
		}

		return commandStep2.send().join();
	}

	// @Test
	// void testPickAnimalHappyPath() throws InterruptedException, TimeoutException
	// {
	// // Given
	// final String username = "Mark";
	// final String animal = "Dog";

	// // When

	// // -> send message to create process instance
	// final PublishMessageResponse publishMessageResponse =
	// sendMessage(PR_CREATED_MSG, "",
	// singletonMap(PR_ID_VAR, pullRequestId));

	// // -> complete user task
	// completeUserTask(REQUEST_REVIEW);

	// // -> send another message to drive the process forward
	// sendMessage(REVIEW_RECEIVED_MSG, pullRequestId,
	// singletonMap(REVIEW_RESULT_VAR, "approved"));

	// // Then
	// BpmnAssert.assertThat(publishMessageResponse)
	// .hasCreatedProcessInstance()
	// .extractingProcessInstance()
	// .hasPassedElementsInOrder(REQUEST_REVIEW, MERGE_CODE, DEPLOY_SNAPSHOT)
	// .hasNotPassedElement(REMIND_REVIEWER)
	// .hasNotPassedElement(MAKE_CHANGES)
	// .hasVariableWithValue(REVIEW_RESULT_VAR, "approved")
	// .extractingLatestCalledProcess()
	// .hasPassedElement(AUTOMATED_TESTS_RUN_TESTS, 3)
	// .isCompleted();
	// }

	private PublishMessageResponse sendMessage(
			final String messageName, final String correlationKey, final Map<String, Object> variables)
			throws InterruptedException, TimeoutException {

		/*
		 * To avoid flaky tests, we recommend publishing messages without a time to live
		 * when using time
		 * manipulation in the same test case. Alternatively, you could plan out the
		 * timings of your time
		 * manipulation and the published message's expiry.
		 * 
		 * In these tests, we assume that a timer event has triggered after the {@code
		 * increaseTime}
		 * method returns. However, this is not guaranteed if a time to live is set
		 * because the message
		 * could expire. Depending on the time to live, the message can expire due to
		 * time manipulation.
		 * 
		 * The {@code increaseTime} method will return after waiting for the engine to
		 * become idle again.
		 * However, message expiry can cause the engine to be busy followed by being
		 * idle again. So, the
		 * increaseTime method can return before the timer event has triggered when a
		 * message expires
		 * due to time manipulation. This can be the cause of a flaky test.
		 * 
		 * Note that by default, the time to live is set to 1 hour.
		 * See {@code ZeebeClientBuilder#defaultTimeToLive}.
		 */
		final Duration timeToLive = Duration.ZERO;

		final PublishMessageResponse response = client
				.newPublishMessageCommand()
				.messageName(messageName)
				.correlationKey(correlationKey)
				.variables(variables)
				.timeToLive(timeToLive)
				.send()
				.join();
		waitForIdleState(Duration.ofSeconds(1));
		return response;
	}

	/*
	 * These two methods deal with the asynchronous nature of the engine. It is
	 * recommended
	 * to wait for an idle state before you assert on the state of the engine.
	 * Otherwise, you
	 * may run into race conditions and flaky tests, depending on whether the engine
	 * is still busy processing your last commands.
	 *
	 * Also note that many of the helper functions used in this test (e.g. {@code
	 * sendMessage(..)}
	 * have a call to this method at the end. This is to ensure that each command
	 * sent to the engine
	 * is fully processed before moving on. Without that you can run into issues,
	 * where e.g. you want
	 * to complete a task, but the task has not been activated yet.
	 *
	 * Note that the duration is not like a {@code Thread.sleep()}. The tests will
	 * continue as soon as
	 * an idle state is reached. Only if no idle state is reached during the {@code
	 * duration}
	 * passed in as argument, then a timeout exception will be thrown.
	 */
	private void waitForIdleState(final Duration duration)
			throws InterruptedException, TimeoutException {
		engine.waitForIdleState(duration);
	}

	private void waitForBusyState(final Duration duration)
			throws InterruptedException, TimeoutException {
		engine.waitForBusyState(duration);
	}
}
